# crib Extensions: Shared Config, Zero-Config, and Transparent Commands

**Date:** 2026-02-20
**Status:** Draft — vision only, implementation deferred post-MVP

## Goal

Extend crib beyond the devcontainer spec with three opinionated developer UX features: automatic injection of shared host configuration (SSH, git, caches), zero-configuration project bootstrapping via convention detection, and transparent command dispatch that works from inside or outside the container. These features are the spiritual successor to devstep's philosophy of "it should just work."

All crib-specific configuration lives under `customizations.crib` in `devcontainer.json`, keeping the file spec-compliant and compatible with other tools.

---

## 1. Shared Host Configuration (`customizations.crib.sharedMounts`)

### Vision

Developers carry configuration around with them — SSH keys, git identity, package manager caches. Today, every devcontainer.json has to rediscover and re-express these. crib should provide a curated set of named "shared config bundles" that a user can opt into once and forget about.

### Approach

A set of named bundles, each mapping to a set of mounts and/or environment variables:

| Bundle | What it injects |
|--------|----------------|
| `ssh` | Mounts `~/.ssh` read-only; forwards `SSH_AUTH_SOCK` if present |
| `gitconfig` | Mounts `~/.gitconfig` and `~/.config/git/` read-only |
| `apt-cache` | Mounts a shared host-side apt cache volume into `/var/cache/apt` |
| `npmrc` | Mounts `~/.npmrc` read-only |
| `pip-cache` | Mounts a shared pip cache volume |
| `docker-config` | Mounts `~/.docker/config.json` for registry auth |

Users opt in via `devcontainer.json`:

```json
{
  "customizations": {
    "crib": {
      "sharedMounts": ["ssh", "gitconfig", "apt-cache"]
    }
  }
}
```

Or globally via `~/.config/crib/config.toml` so they never have to think about it per-project:

```toml
defaultSharedMounts = ["ssh", "gitconfig"]
```

### Key Decisions (TBD)

- Per-project config overrides vs. merges with global defaults
- Whether to support custom user-defined bundles
- Handling rootless Podman volume permission differences

---

## 2. Zero-Configuration Bootstrapping

### Vision

`crib up` in a repo with no `.devcontainer/` should not fail — it should detect the project type, select an appropriate base image, generate a `devcontainer.json`, and commit it. The generated file is a first-class artifact: portable, editable, and usable by VS Code or the official CLI.

The mental model: crib as a smart scaffolder, not a black box. You always end up with an explicit config file.

### Approach

Convention detection priority order:

1. Check for existing `.devcontainer/devcontainer.json` — use it as-is
2. Walk project root for known convention files:

| File detected | Base image |
|--------------|------------|
| `go.mod` | `mcr.microsoft.com/devcontainers/go` |
| `Gemfile` | `mcr.microsoft.com/devcontainers/ruby` |
| `package.json` | `mcr.microsoft.com/devcontainers/javascript-node` |
| `requirements.txt` / `pyproject.toml` | `mcr.microsoft.com/devcontainers/python` |
| `Cargo.toml` | `mcr.microsoft.com/devcontainers/rust` |
| `composer.json` | `mcr.microsoft.com/devcontainers/php` |
| _(none matched)_ | `mcr.microsoft.com/devcontainers/base:ubuntu` |

3. Generate `.devcontainer/devcontainer.json` with the detected image and any default `customizations.crib` settings from global config
4. Print what was generated and why, then proceed with `crib up`

Users can opt out of auto-generation (`--no-generate`) or run detection standalone (`crib init`).

### Key Decisions (TBD)

- Whether to detect multiple languages and suggest a compose-based setup
- Version pinning strategy for generated base images
- Whether `crib init` is a separate command or an alias for `crib up --dry-run`

---

## 3. Transparent Command Dispatch (`customizations.crib.commands`)

### Vision

`crib run <cmd>` executes a named command in the devcontainer, whether you're already inside it or not. Think `npm run` but container-aware: same command, same output, works from anywhere in the project tree.

Optional bin stubs let you skip even typing `crib run` — a stub on your `$PATH` detects context and delegates.

### Approach

Commands are defined in `devcontainer.json`:

```json
{
  "customizations": {
    "crib": {
      "commands": {
        "test": "pytest -xvs",
        "lint": "ruff check . && mypy .",
        "server": "flask run --reload"
      }
    }
  }
}
```

**Dispatch logic:**
- If already inside the crib container → run directly
- If outside → `docker exec` (or `podman exec`) into the running container, or start it first if stopped

**Bin stubs** (opt-in, generated by `crib stubs`):

```
.crib/bin/
└── test    # shell stub: detects if in crib project, runs `crib run test`
```

Committed to the project repo. Users add `.crib/bin` to `$PATH` (e.g. via direnv: `PATH_add .crib/bin`). Running `test` anywhere in the project tree transparently dispatches into the container.

### Key Decisions (TBD)

- How stubs detect "am I in a crib project" (walk up looking for `.devcontainer/`)
- Whether stubs are global or per-project symlinks
- Interactive vs. non-interactive TTY handling
- Exit code and signal passthrough

---

## Future Extensions

- **`crib run --watch`** — re-run command on file changes (inside container)
- **Custom bundle definitions** — user-defined shared mount bundles in `~/.crib/config.toml`
- **Multi-language detection** — generate compose-based devcontainer for polyglot repos
- **`crib doctor`** — diagnose common config and runtime issues

---

*Written in collaboration with Claude (Sonnet 4.6).*
